{"version":3,"file":"modelz.min.js","sources":["src/util.js","src/index.js"],"sourcesContent":["'use strict'\n\nexport function noop() {}\n\nexport function identity(thing) {\n  return thing\n}\n\nexport function type(obj) {\n  return {}.toString.call(obj)\n}\n\nexport function isObject(thing) {\n  return thing !== null && type(thing) === '[object Object]'\n}\n\nexport function isArray(thing) {\n  return type(thing) == '[object Array]'\n}\n\nexport function isFunction(thing) {\n  return typeof thing === 'function'\n}\n\nexport function isString(thing) {\n  return typeof thing === 'string'\n}\n\nexport function isNumber(thing) {\n  return typeof thing === 'number'\n}\n\nexport function isUndefined(thing) {\n  return typeof thing === 'undefined'\n}\n","'use strict'\n\nimport {\n  identity,\n  isArray,\n  isFunction,\n  isNumber,\n  isObject,\n  isString,\n  noop,\n} from './util'\n\nconst defaultFieldConfig = {\n  construct: identity,\n  getCacheKey: noop,\n  enumerable: true,\n  required: false,\n}\n\nconst defaultGlobalConfig = {\n  castString: true,\n  parseNumbers: true,\n  onChangeListener: function() {\n    return noop\n  },\n  extraProperties: false,\n  embedPlainData: true,\n  preInit: identity,\n  postInit: identity,\n  types: {},\n}\n\nfunction createCacheFunction(depProps) {\n  return function(obj) {\n    return depProps.map(prop => obj[prop]).join('|<3|')\n  }\n}\n\nfunction modelz(globalConfig) {\n  globalConfig = Object.assign({}, defaultGlobalConfig, globalConfig)\n  function getConstructor(item, fieldname) {\n    const constructors = Object.assign(\n      {\n        string(value) {\n          if (isString(value)) {\n            return value\n          }\n          if (globalConfig.castString) {\n            return '' + value\n          }\n          throw Error(`Expect a string for \"${fieldname}\", got \"${value}\"`)\n        },\n        number(value) {\n          if (isNumber(value)) {\n            return value\n          }\n          if (isString(value) && globalConfig.parseNumbers) {\n            return parseFloat(value)\n          }\n          throw Error(`Expect a number for \"${fieldname}\", got \"${value}\"`)\n        },\n        boolean(value) {\n          return !!value\n        },\n        array(value) {\n          return [].concat(value)\n        },\n        object(value) {\n          return Object.assign({}, value)\n        },\n        date(value) {\n          return new Date(value)\n        },\n        identity,\n      },\n      globalConfig.types\n    )\n\n    if (isFunction(item)) {\n      return item\n    }\n    if (constructors[item] == null) {\n      throw Error(\n        `Try to use unknown type \"${item}\" as type for \"${fieldname}\"`\n      )\n    }\n    return constructors[item]\n  }\n  function parseConfig(fieldConfig, fieldname) {\n    if (isObject(fieldConfig)) {\n      if (isFunction(fieldConfig.construct)) {\n        // constructor\n        return fieldConfig\n      }\n\n      if (isString(fieldConfig.type)) {\n        // type\n        return Object.assign(\n          {\n            construct: getConstructor(fieldConfig.type, fieldname),\n          },\n          fieldConfig\n        )\n      }\n\n      if (\n        isArray(fieldConfig.get) &&\n        isFunction(fieldConfig.get[0]) &&\n        (isFunction(fieldConfig.get[1]) || isArray(fieldConfig.get[1]))\n      ) {\n        // computed property with cache function\n        return {\n          getCacheKey: isArray(fieldConfig.get[1])\n            ? createCacheFunction(fieldConfig.get[1])\n            : fieldConfig.get[1],\n          get: fieldConfig.get[0],\n          set: fieldConfig.set,\n        }\n      }\n\n      if (isFunction(fieldConfig.get)) {\n        // computed property\n        return {\n          getCacheKey: noop,\n          get: fieldConfig.get,\n          set: fieldConfig.set,\n        }\n      }\n    }\n\n    if (isArray(fieldConfig) && fieldConfig.length === 2) {\n      // short syntax without default [type, required]\n      const [type, required] = fieldConfig\n      return {\n        construct: getConstructor(type, fieldname),\n        required,\n      }\n    }\n\n    if (isArray(fieldConfig) && fieldConfig.length === 3) {\n      // short syntax [type, required, default]\n      const [type, required, defaultValue] = fieldConfig\n      return {\n        construct: getConstructor(type, fieldname),\n        required,\n        default: defaultValue,\n      }\n    }\n\n    if (isFunction(fieldConfig)) {\n      // plain construct\n      return {\n        construct: fieldConfig,\n      }\n    }\n\n    if (isString(fieldConfig)) {\n      try {\n        // init by type\n        return {\n          construct: getConstructor(fieldConfig, fieldname),\n        }\n      } catch (e) {\n        // fail silently and try next init\n      }\n    }\n\n    try {\n      // init by default\n      return {\n        construct: getConstructor(typeof fieldConfig, fieldname),\n        required: true,\n        default: fieldConfig,\n      }\n    } catch (e) {\n      throw new Error(\n        `No proper config handler found for config:\\n${JSON.stringify(\n          fieldConfig\n        )}`\n      )\n    }\n  }\n\n  return function Schema(fields, config) {\n    config = Object.assign({}, globalConfig, config)\n    return function construct(data = {}) {\n      const _data = {}\n      let onChange = noop\n\n      let result = {}\n      if (config.extraProperties) {\n        result = Object.assign({}, data)\n      }\n\n      if (config.embedPlainData) {\n        Object.defineProperty(result, '_data', {\n          get: () => _data,\n          enumerable: false,\n        })\n      }\n      result = config.preInit(result)\n      onChange = config.onChangeListener(result)\n      for (const fieldname in fields) {\n        if (!fields.hasOwnProperty(fieldname)) {\n          continue\n        }\n        const fieldConfig = Object.assign(\n          {},\n          defaultFieldConfig,\n          parseConfig(fields[fieldname], fieldname)\n        )\n        if (data.hasOwnProperty(fieldname)) {\n          if (data[fieldname] == null) {\n            _data[fieldname] = data[fieldname]\n          } else {\n            _data[fieldname] = fieldConfig.construct(data[fieldname], result)\n          }\n        } else if (fieldConfig.default === null) {\n          _data[fieldname] = fieldConfig.default\n        } else if (fieldConfig.hasOwnProperty('default')) {\n          _data[fieldname] = fieldConfig.construct(fieldConfig.default, result)\n        } else if (fieldConfig.required) {\n          throw Error(`No value set for ${fieldname}`)\n        }\n        Object.defineProperty(result, fieldname, {\n          enumerable: !isFunction(fieldConfig.get) && fieldConfig.enumerable,\n          get: function() {\n            if (fieldConfig.get) {\n              const key = fieldConfig.getCacheKey(result)\n              if (\n                !_data.hasOwnProperty(fieldname) ||\n                key == null ||\n                key !== _data[fieldname].key\n              ) {\n                _data[fieldname] = {\n                  key,\n                  value: fieldConfig.get(result),\n                }\n              }\n              return _data[fieldname].value\n            }\n            return result._data[fieldname]\n          },\n          set: function(value) {\n            const oldValue = result[fieldname]\n            if (isFunction(fieldConfig.set)) {\n              fieldConfig.set(result, value)\n            } else {\n              _data[fieldname] = fieldConfig.construct(value)\n            }\n            onChange(fieldname, value, oldValue)\n          },\n        })\n      }\n      result = config.postInit(result)\n      if (!globalConfig.extraProperties) {\n        Object.seal(result)\n      }\n      return result\n    }\n  }\n}\n\nexport default modelz\n"],"names":["noop","identity","thing","type","obj","toString","call","isArray","isFunction","isString","const","defaultFieldConfig","construct","getCacheKey","enumerable","required","defaultGlobalConfig","castString","parseNumbers","onChangeListener","extraProperties","embedPlainData","preInit","postInit","types","globalConfig","getConstructor","item","fieldname","constructors","Object","assign","string","value","Error","number","parseFloat","boolean","array","concat","object","date","Date","parseConfig","fieldConfig","get","depProps","map","prop","join","set","length","default","defaultValue","e","JSON","stringify","fields","config","data","_data","onChange","result","defineProperty","hasOwnProperty","key","oldValue","seal"],"mappings":"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"}