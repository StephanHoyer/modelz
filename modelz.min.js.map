{"version":3,"file":"modelz.min.js","sources":["src/util.js","src/index.js"],"sourcesContent":["'use strict'\n\nexport function noop() {}\n\nexport function identity(thing) {\n  return thing\n}\n\nexport function type(obj) {\n  return {}.toString.call(obj)\n}\n\nexport function isObject(thing) {\n  return thing !== null && type(thing) === '[object Object]'\n}\n\nexport function isArray(thing) {\n  return type(thing) == '[object Array]'\n}\n\nexport function isFunction(thing) {\n  return typeof thing === 'function'\n}\n\nexport function isString(thing) {\n  return typeof thing === 'string'\n}\n\nexport function isNumber(thing) {\n  return typeof thing === 'number'\n}\n\nexport function isUndefined(thing) {\n  return typeof thing === 'undefined'\n}\n","'use strict'\n\nimport {\n  identity,\n  isArray,\n  isFunction,\n  isNumber,\n  isObject,\n  isString,\n  noop,\n} from './util'\n\nconst defaultFieldConfig = {\n  construct: identity,\n  getCacheKey: noop,\n  enumerable: true,\n  required: false,\n}\n\nconst defaultGlobalConfig = {\n  castString: true,\n  parseNumbers: true,\n  onChangeListener: function() {\n    return noop\n  },\n  extraProperties: false,\n  embedPlainData: true,\n  preInit: identity,\n  postInit: identity,\n  types: {},\n}\n\nfunction createCacheFunction(depProps) {\n  return function(obj) {\n    return depProps.map(prop => obj[prop]).join('|<3|')\n  }\n}\n\nfunction modelz(globalConfig) {\n  globalConfig = Object.assign({}, defaultGlobalConfig, globalConfig)\n  function getConstructor(item, fieldname) {\n    const constructors = Object.assign(\n      {\n        string(value) {\n          if (isString(value)) {\n            return value\n          }\n          if (globalConfig.castString) {\n            return '' + value\n          }\n          throw Error(`Expect a string for \"${fieldname}\", got \"${value}\"`)\n        },\n        number(value) {\n          if (isNumber(value)) {\n            return value\n          }\n          if (isString(value) && globalConfig.parseNumbers) {\n            return parseFloat(value)\n          }\n          throw Error(`Expect a number for \"${fieldname}\", got \"${value}\"`)\n        },\n        boolean(value) {\n          return !!value\n        },\n        array(value) {\n          return [].concat(value)\n        },\n        object(value) {\n          return Object.assign({}, value)\n        },\n        date(value) {\n          return new Date(value)\n        },\n        identity,\n      },\n      globalConfig.types\n    )\n\n    if (isFunction(item)) {\n      return item\n    }\n    if (constructors[item] == null) {\n      throw Error(\n        `Try to use unknown type \"${item}\" as type for \"${fieldname}\"`\n      )\n    }\n    return constructors[item]\n  }\n  function parseConfig(fieldConfig, fieldname) {\n    if (isObject(fieldConfig)) {\n      if (isFunction(fieldConfig.construct)) {\n        // constructor\n        return fieldConfig\n      }\n\n      if (isString(fieldConfig.type)) {\n        // type\n        return Object.assign(\n          {\n            construct: getConstructor(fieldConfig.type, fieldname),\n          },\n          fieldConfig\n        )\n      }\n\n      if (\n        isArray(fieldConfig.get) &&\n        isFunction(fieldConfig.get[0]) &&\n        (isFunction(fieldConfig.get[1]) || isArray(fieldConfig.get[1]))\n      ) {\n        // computed property with cache function\n        return {\n          getCacheKey: isArray(fieldConfig.get[1])\n            ? createCacheFunction(fieldConfig.get[1])\n            : fieldConfig.get[1],\n          get: fieldConfig.get[0],\n          set: fieldConfig.set,\n        }\n      }\n\n      if (isFunction(fieldConfig.get)) {\n        // computed property\n        return {\n          getCacheKey: noop,\n          get: fieldConfig.get,\n          set: fieldConfig.set,\n        }\n      }\n    }\n\n    if (isArray(fieldConfig) && fieldConfig.length === 2) {\n      // short syntax without default [type, required]\n      const [type, required] = fieldConfig\n      return {\n        construct: getConstructor(type, fieldname),\n        required,\n      }\n    }\n\n    if (isArray(fieldConfig) && fieldConfig.length === 3) {\n      // short syntax [type, required, default]\n      const [type, required, defaultValue] = fieldConfig\n      return {\n        construct: getConstructor(type, fieldname),\n        required,\n        default: defaultValue,\n      }\n    }\n\n    if (isFunction(fieldConfig)) {\n      // plain construct\n      return {\n        construct: fieldConfig,\n      }\n    }\n\n    if (isString(fieldConfig)) {\n      try {\n        // init by type\n        return {\n          construct: getConstructor(fieldConfig, fieldname),\n        }\n      } catch (e) {\n        // fail silently and try next init\n      }\n    }\n\n    try {\n      // init by default\n      return {\n        construct: getConstructor(typeof fieldConfig, fieldname),\n        required: true,\n        default: fieldConfig,\n      }\n    } catch (e) {\n      throw new Error(\n        `No proper config handler found for config:\\n${JSON.stringify(\n          fieldConfig\n        )}`\n      )\n    }\n  }\n\n  return function Schema(fields, config) {\n    config = Object.assign({}, globalConfig, config)\n    return function construct(sourceData = {}) {\n      if (sourceData._isInitialized) {\n        return sourceData\n      }\n      const _data = {}\n      let onChange = noop\n\n      let result = {}\n      if (config.extraProperties) {\n        result = Object.assign({}, sourceData)\n      }\n\n      if (config.embedPlainData) {\n        Object.defineProperty(result, '_data', {\n          get: () => _data,\n          enumerable: false,\n        })\n      }\n      Object.defineProperty(result, '_isInitialized', {\n        get: () => true,\n        enumerable: false,\n      })\n      result = config.preInit(result)\n      onChange = config.onChangeListener(result)\n      for (const fieldname in fields) {\n        const fieldConfig = Object.assign(\n          {},\n          defaultFieldConfig,\n          parseConfig(fields[fieldname], fieldname)\n        )\n        Object.defineProperty(result, fieldname, {\n          enumerable: !isFunction(fieldConfig.get) && fieldConfig.enumerable,\n          get: function() {\n            if (fieldConfig.get) {\n              const key = fieldConfig.getCacheKey(result)\n              if (\n                !_data.hasOwnProperty(fieldname) ||\n                key == null ||\n                key !== _data[fieldname].key\n              ) {\n                _data[fieldname] = { key, value: fieldConfig.get(result) }\n              }\n              return _data[fieldname].value\n            }\n            return result._data[fieldname]\n          },\n          set: function(value) {\n            const oldValue = result[fieldname]\n            if (isFunction(fieldConfig.set)) {\n              fieldConfig.set(result, value)\n            } else if (!fieldConfig.required && value == null) {\n              _data[fieldname] = value = null\n            } else {\n              _data[fieldname] = fieldConfig.construct(\n                value,\n                result,\n                fieldConfig\n              )\n            }\n            onChange(fieldname, value, oldValue)\n          },\n        })\n\n        if (sourceData[fieldname] != null) {\n          result[fieldname] = sourceData[fieldname]\n        } else if (fieldConfig.hasOwnProperty('default')) {\n          if (isFunction(fieldConfig.default)) {\n            result[fieldname] = fieldConfig.default()\n          } else {\n            result[fieldname] = fieldConfig.default\n          }\n        } else if (fieldConfig.required) {\n          throw Error('No value set for ' + fieldname)\n        } else if (!fieldConfig.get) {\n          // default to null if it's not a computed prop\n          result[fieldname] = null\n        }\n      }\n      result = config.postInit(result)\n      if (!globalConfig.extraProperties) {\n        Object.seal(result)\n      }\n      return result\n    }\n  }\n}\n\nexport default modelz\n"],"names":["noop","identity","thing","type","obj","toString","call","isArray","isFunction","isString","const","defaultFieldConfig","construct","getCacheKey","enumerable","required","defaultGlobalConfig","castString","parseNumbers","onChangeListener","extraProperties","embedPlainData","preInit","postInit","types","globalConfig","getConstructor","item","fieldname","constructors","Object","assign","string","value","Error","number","parseFloat","boolean","array","concat","object","date","Date","parseConfig","fieldConfig","get","depProps","map","prop","join","set","length","default","defaultValue","e","JSON","stringify","fields","config","sourceData","_isInitialized","_data","onChange","result","defineProperty","key","hasOwnProperty","oldValue","seal"],"mappings":"4LAEO,SAASA,KAET,SAASC,EAASC,GACvB,OAAOA,EAGF,SAASC,EAAKC,GACnB,MAAO,GAAGC,SAASC,KAAKF,GAOnB,SAASG,EAAQL,GACtB,MAAsB,kBAAfC,EAAKD,GAGP,SAASM,EAAWN,GACzB,MAAwB,mBAAVA,EAGT,SAASO,EAASP,GACvB,MAAwB,iBAAVA,ECbhBQ,IAAMC,EAAqB,CACzBC,UAAWX,EACXY,YAAab,EACbc,YAAY,EACZC,UAAU,GAGNC,EAAsB,CAC1BC,YAAY,EACZC,cAAc,EACdC,iBAAkB,WAChB,OAAOnB,GAEToB,iBAAiB,EACjBC,gBAAgB,EAChBC,QAASrB,EACTsB,SAAUtB,EACVuB,MAAO,WAST,SAAgBC,GAEd,SAASC,EAAeC,EAAMC,GAC5BlB,IAAMmB,EAAeC,OAAOC,OAC1B,CACEC,gBAAOC,GACL,GAAIxB,EAASwB,GACX,OAAOA,EAET,GAAIR,EAAaR,WACf,MAAO,GAAKgB,EAEd,MAAMC,8BAA8BN,aAAoBK,QAE1DE,gBAAOF,GACL,GDxBgB,iBCwBHA,EACX,OAAOA,EAET,GAAIxB,EAASwB,IAAUR,EAAaP,aAClC,OAAOkB,WAAWH,GAEpB,MAAMC,8BAA8BN,aAAoBK,QAE1DI,iBAAQJ,GACN,QAASA,GAEXK,eAAML,GACJ,MAAO,GAAGM,OAAON,IAEnBO,gBAAOP,GACL,OAAOH,OAAOC,OAAO,GAAIE,IAE3BQ,cAAKR,GACH,OAAO,IAAIS,KAAKT,aAElBhC,GAEFwB,EAAaD,OAGf,GAAIhB,EAAWmB,GACb,OAAOA,EAET,GAA0B,MAAtBE,EAAaF,GACf,MAAMO,kCACwBP,oBAAsBC,OAGtD,OAAOC,EAAaF,GAEtB,SAASgB,EAAYC,EAAahB,GAChC,GD5Ee,QADM1B,EC6ER0C,ID5E0B,oBAAhBzC,EAAKD,GC4ED,CACzB,GAAIM,EAAWoC,EAAYhC,WAEzB,OAAOgC,EAGT,GAAInC,EAASmC,EAAYzC,MAEvB,OAAO2B,OAAOC,OACZ,CACEnB,UAAWc,EAAekB,EAAYzC,KAAMyB,IAE9CgB,GAIJ,GACErC,EAAQqC,EAAYC,MACpBrC,EAAWoC,EAAYC,IAAI,MAC1BrC,EAAWoC,EAAYC,IAAI,KAAOtC,EAAQqC,EAAYC,IAAI,KAG3D,MAAO,CACLhC,YAAaN,EAAQqC,EAAYC,IAAI,KAhFlBC,EAiFKF,EAAYC,IAAI,GAhFzC,SAASzC,GACd,OAAO0C,EAASC,aAAIC,UAAQ5C,EAAI4C,KAAOC,KAAK,UAgFlCL,EAAYC,IAAI,GACpBA,IAAKD,EAAYC,IAAI,GACrBK,IAAKN,EAAYM,KAIrB,GAAI1C,EAAWoC,EAAYC,KAEzB,MAAO,CACLhC,YAAab,EACb6C,IAAKD,EAAYC,IACjBK,IAAKN,EAAYM,KA7F3B,IAA6BJ,EDpBJ5C,ECsHrB,GAAIK,EAAQqC,IAAuC,IAAvBA,EAAYO,OAAc,CAEpD,kBACA,MAAO,CACLvC,UAAWc,EAAevB,EAAMyB,YAChCb,GAIJ,GAAIR,EAAQqC,IAAuC,IAAvBA,EAAYO,OAAc,CAEpD,yBACA,MAAO,CACLvC,UAAWc,EAAevB,EAAMyB,YAChCb,EACAqC,QAASC,GAIb,GAAI7C,EAAWoC,GAEb,MAAO,CACLhC,UAAWgC,GAIf,GAAInC,EAASmC,GACX,IAEE,MAAO,CACLhC,UAAWc,EAAekB,EAAahB,IAEzC,MAAO0B,IAKX,IAEE,MAAO,CACL1C,UAAWc,SAAsBkB,EAAahB,GAC9Cb,UAAU,EACVqC,QAASR,GAEX,MAAOU,GACP,MAAM,IAAIpB,qDACuCqB,KAAKC,UAClDZ,KAMR,OAhJAnB,EAAeK,OAAOC,OAAO,GAAIf,EAAqBS,GAgJ/C,SAAgBgC,EAAQC,GAE7B,OADAA,EAAS5B,OAAOC,OAAO,GAAIN,EAAciC,GAClC,SAAmBC,GACxB,kBADqC,IACjCA,EAAWC,eACb,OAAOD,EAETjD,IAAMmD,EAAQ,GACVC,EAAW9D,EAEX+D,EAAS,GACTL,EAAOtC,kBACT2C,EAASjC,OAAOC,OAAO,GAAI4B,IAGzBD,EAAOrC,gBACTS,OAAOkC,eAAeD,EAAQ,QAAS,CACrClB,sBAAWgB,GACX/C,YAAY,IAGhBgB,OAAOkC,eAAeD,EAAQ,iBAAkB,CAC9ClB,sBAAW,GACX/B,YAAY,IAEdiD,EAASL,EAAOpC,QAAQyC,GACxBD,EAAWJ,EAAOvC,iBAAiB4C,qBAEjCrD,IAAMkC,EAAcd,OAAOC,OACzB,GACApB,EACAgC,EAAYc,EAAO7B,GAAYA,IAmCjC,GAjCAE,OAAOkC,eAAeD,EAAQnC,EAAW,CACvCd,YAAaN,EAAWoC,EAAYC,MAAQD,EAAY9B,WACxD+B,IAAK,WACH,GAAID,EAAYC,IAAK,CACnBnC,IAAMuD,EAAMrB,EAAY/B,YAAYkD,GAQpC,OANGF,EAAMK,eAAetC,IACf,MAAPqC,GACAA,IAAQJ,EAAMjC,GAAWqC,MAEzBJ,EAAMjC,GAAa,KAAEqC,EAAKhC,MAAOW,EAAYC,IAAIkB,KAE5CF,EAAMjC,GAAWK,MAE1B,OAAO8B,EAAOF,MAAMjC,IAEtBsB,IAAK,SAASjB,GACZvB,IAAMyD,EAAWJ,EAAOnC,GACpBpB,EAAWoC,EAAYM,KACzBN,EAAYM,IAAIa,EAAQ9B,GACdW,EAAY7B,UAAqB,MAATkB,EAGlC4B,EAAMjC,GAAagB,EAAYhC,UAC7BqB,EACA8B,EACAnB,GALFiB,EAAMjC,GAAaK,EAAQ,KAQ7B6B,EAASlC,EAAWK,EAAOkC,MAIF,MAAzBR,EAAW/B,GACbmC,EAAOnC,GAAa+B,EAAW/B,QAC1B,GAAIgB,EAAYsB,eAAe,WAChC1D,EAAWoC,EAAYQ,SACzBW,EAAOnC,GAAagB,EAAYQ,UAEhCW,EAAOnC,GAAagB,EAAYQ,YAE7B,CAAA,GAAIR,EAAY7B,SACrB,MAAMmB,MAAM,oBAAsBN,GACxBgB,EAAYC,MAEtBkB,EAAOnC,GAAa,QAnDxB,IAAKlB,IAAMkB,KAAa6B,OA0DxB,OAJAM,EAASL,EAAOnC,SAASwC,GACpBtC,EAAaL,iBAChBU,OAAOsC,KAAKL,GAEPA"}